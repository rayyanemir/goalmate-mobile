# goalmate-mobile

*Tugas 7*
1. Widget tree adalah struktur susunan widget dalam aplikasi Flutter yang tersusun seperti pohon. Setiap tampilan yang muncul di layar berasal dari widget yang saling membungkus satu sama lain. Hubungan parent-child berarti satu widget dapat menjadi induk yang mengatur widget lain di dalamnya sebagai anak, termasuk bagaimana anak tersebut ditampilkan, seperti posisinya, ukurannya, atau gaya visualnya. Semua hal yang terlihat di aplikasi, mulai dari background hingga tombol, berada dalam widget tree ini.

2. Dalam proyek ini, saya menggunakan beberapa widget dasar yang sering dipakai di Flutter. MaterialApp digunakan sebagai kerangka utama aplikasi dan untuk mengatur navigasi. Setiap halaman memakai Scaffold supaya ada struktur yang jelas seperti body dan bottom navigation bar. Untuk berpindah halaman, saya memakai BottomNavigationBar dengan ikon yang mewakili menu Home, Friends, dan Profile. Pada halaman login dan register, saya menggunakan TextField untuk input email dan password, kemudian ElevatedButton sebagai tombol untuk melakukan aksi. Beberapa widget layout seperti Column, Row, dan Container saya pakai untuk mengatur posisi dan tampilan elemen di layar. Selain itu juga ada Text untuk tulisan, Icon untuk menampilkan gambar ikon, dan SnackBar untuk menampilkan pesan singkat setelah tombol ditekan. Semua widget itu saling digabungkan untuk membentuk tampilan aplikasi yang bisa digunakan.

3. MaterialApp berperan sebagai fondasi aplikasi berbasis Material Design. Widget ini mengatur banyak hal penting seperti navigasi antar halaman, tema warna, gaya teks, hingga pengaturan global lainnya yang memengaruhi seluruh aplikasi. Karena menjadi pusat konfigurasi utama dan memastikan semua widget Material lain bisa berfungsi dengan baik, MaterialApp hampir selalu ditempatkan sebagai widget root dalam sebuah aplikasi Flutter.

4. StatelessWidget digunakan untuk tampilan yang tidak berubah setelah widget dibangun pertama kali, misalnya teks statis atau ikon. Sementara itu, StatefulWidget digunakan pada tampilan yang bisa berubah saat aplikasi berjalan, misalnya ketika pengguna mengetik sesuatu di form, menekan tombol, atau saat data diperbarui. Pemilihan antara keduanya bergantung pada apakah UI akan berubah mengikuti interaksi atau tidak.

5. BuildContext adalah objek yang menyimpan informasi posisi sebuah widget di dalam widget tree. Dengan konteks ini, widget dapat mengakses data dari induknya seperti tema aplikasi, ukuran layar, navigator, dan elemen visual lain yang membutuhkannya. BuildContext digunakan pada metode build karena proses membangun tampilan membutuhkan referensi ini untuk menampilkan widget yang sesuai di lokasi yang benar.

6. Hot reload memungkinkan developer melihat perubahan tampilan secara langsung tanpa kehilangan state aplikasi, sehingga sangat cepat dan nyaman untuk pengembangan UI. Di sisi lain, hot restart memuat ulang seluruh aplikasi dari awal dan akan menghapus state yang sedang berjalan. Meskipun lebih lambat, hot restart diperlukan ketika perubahan menyangkut logika dasar atau konfigurasi awal aplikasi yang tidak dapat diperbarui lewat hot reload.

*Tugas 8*

1. Navigator.push() akan menambahkan halaman baru ke dalam stack navigasi tanpa menghapus halaman sebelumnya. Pengguna masih dapat kembali ke halaman sebelumnya menggunakan tombol back. Sementara itu, Navigator.pushReplacement() mengganti halaman yang sedang ditampilkan dengan halaman baru dan menghapus halaman sebelumnya dari stack. Setelah berpindah, pengguna tidak bisa kembali ke halaman tersebut dengan tombol back. Penggunaan di aplikasi Football Shop:
- Navigator.push() cocok saat membuka halaman form “Add Product” karena pengguna mungkin ingin kembali ke halaman sebelumnya setelah menambahkan produk.
- Navigator.pushReplacement() cocok digunakan ketika setelah form selesai disubmit, aplikasi kembali ke halaman awal tanpa perlu kembali lagi ke form

2. Pada Flutter, Scaffold berfungsi sebagai struktur dasar setiap halaman, sehingga semua halaman di aplikasi Football Shop memiliki pola tampilan yang konsisten. Di dalam Scaffold terdapat AppBar sebagai bagian atas halaman yang menampilkan judul, memberikan konteks kepada pengguna tentang halaman yang sedang dibuka. Selain itu, Drawer digunakan pada sisi kiri, yang memberikan akses navigasi yang mudah antar halaman seperti Home, Add Product, dan Product List. Dengan memanfaatkan hierarchy widget ini secara konsisten, pengguna akan merasa familiar saat berpindah halaman karena tata letaknya serupa. Hal ini meningkatkan user experience dan mempermudah pengembangan aplikasi karena struktur dibuat seragam di semua layar. 

3. Dalam form aplikasi Football Shop, layout widget seperti Padding, SingleChildScrollView, dan ListView berperan penting untuk memastikan tampilan tetap rapi dan nyaman digunakan. Padding membantu menjaga jarak antar elemen sehingga tidak terlihat menumpuk dan membuat pengguna lebih mudah fokus pada setiap input. SingleChildScrollView memungkinkan seluruh konten tetap dapat diakses dengan menggulir layar ketika jumlah elemen form cukup panjang atau saat keyboard muncul, sehingga tidak terjadi overflow. Sementara itu, ListView digunakan ketika menampilkan banyak elemen yang sifatnya dinamis, seperti daftar produk, karena widget ini secara otomatis mendukung scrolling dan pengelolaan space yang efisien. Dengan memanfaatkan ketiga widget tersebut, tampilan form dapat menyesuaikan ukuran layar dengan baik dan memberikan pengalaman pengguna yang lebih nyaman.

4. Aplikasi Football Shop menggunakan ThemeData untuk menjaga konsistensi identitas visual di seluruh halaman. Warna utama diterapkan pada komponen seperti AppBar, tombol, dan elemen penting lain agar aplikasi memiliki tampilan yang seragam dan mudah dikenali sebagai brand toko. Dengan menerapkan warna tema secara global, perubahan warna dapat dilakukan di satu tempat tanpa perlu memperbarui setiap widget secara manual. Hal ini membantu menjaga kesan profesional dan memudahkan pengembangan aplikasi ke depannya, terutama ketika brand ingin melakukan penyesuaian tampilan.

*Tugas 9*

1. Model Dart dibutuhkan supaya data dari Django tidak hanya berupa Map mentah, tetapi berubah menjadi objek dengan tipe yang jelas. Dengan model, setiap field punya tipe yang pasti sehingga aman untuk null-safety dan lebih mudah dilacak kalau ada kesalahan. Tanpa model, kita harus mengakses data dengan string key dari Map yang rentan typo, rawan runtime error, dan sulit dipelihara ketika aplikasi semakin besar. Model juga membuat parsing, validasi tipe, dan penulisan kode yang konsisten jauh lebih mudah.

2. Package http adalah package standar Flutter untuk melakukan request umum tanpa autentikasi. Sementara CookieRequest adalah bagian dari pbp_django_auth yang secara otomatis menyimpan dan mengirim cookie sesi Django. Karena project ini memakai login Django dengan session-based authentication, CookieRequest memegang peran penting agar setiap request dari Flutter membawa cookie login secara otomatis. Jadi http cocok untuk request publik, sedangkan CookieRequest digunakan saat butuh login dan interaksi dengan endpoint Django yang memerlukan identitas user.

3. CookieRequest harus dibagikan lewat Provider supaya seluruh halaman Flutter memakai instance yang sama. Ini membuat cookie yang tersimpan saat login tetap dibawa ke semua halaman lain, termasuk saat mengambil data user, memanggil endpoint JSON, atau mengirim form. Kalau setiap halaman membuat instance baru, cookie akan hilang dan user dianggap belum login, sehingga autentikasi gagal. Dengan membagikan satu instance, status login konsisten di seluruh aplikasi.

4. Agar Flutter bisa mengakses Django, beberapa konfigurasi harus dilakukan. Django harus menambahkan domain deployment dan 10.0.2.2 ke dalam ALLOWED_HOSTS supaya request dari emulator dan browser diizinkan. CORS juga perlu diaktifkan agar permintaan lintas origin tidak diblokir. Selain itu, Django harus mengatur cookie dan SameSite supaya cookie sesi bisa dikirim kembali dari Flutter. Di Android, aplikasi juga harus diberi izin akses internet melalui manifest. Jika salah satu konfigurasi tidak dilakukan, Flutter tidak dapat terhubung ke Django, request akan gagal, pengguna tidak bisa login, atau session cookie tidak tersimpan.

5. Ketika pengguna mengisi form pada Flutter, data dikumpulkan dan dikirim melalui CookieRequest ke Django dalam format JSON atau form data. Django menerima request, memvalidasi input, menyimpan data ke database, lalu mengembalikan respons JSON. Flutter membaca JSON ini, mengubahnya menjadi objek model Dart, dan menampilkannya pada widget seperti ListView atau detail page. Setiap langkah dari input–request–respons–parsing–render berlangsung secara berurutan.

6. Saat pengguna login di Flutter, username dan password dikirim ke endpoint login Django melalui CookieRequest. Django memverifikasi kredensial, membuat session, dan mengirimkan cookie sesi kembali ke Flutter. CookieRequest menyimpannya secara otomatis. Setelah login berhasil, Flutter dapat mengakses endpoint yang memerlukan autentikasi, seperti /json/my/, dan Django mengenali pengguna berdasarkan cookie tersebut. Logout bekerja dengan menghapus sesi di Django, dan CookieRequest juga menghapus cookie lokal sehingga pengguna dianggap tidak lagi login.

7. Saya memulai dengan memastikan Django berhasil dideploy dan endpoint JSON dapat diakses dari luar. Setelah itu saya membuat form registrasi di Flutter yang terhubung ke Django melalui CookieRequest, sehingga pengguna baru dapat membuat akun. Lalu saya membangun halaman login yang mengirim kredensial ke Django dan menyimpan cookie sesi setelah verifikasi berhasil. CookieRequest kemudian saya bagikan ke seluruh aplikasi lewat Provider agar status login konsisten di setiap halaman. Setelah autentikasi bekerja, saya membuat model Dart yang sesuai dengan model Django untuk memastikan parsing JSON rapi dan aman. Selanjutnya saya membuat halaman daftar produk dengan memanggil endpoint JSON, memetakan respons ke model Dart, dan menampilkan item dalam bentuk card. Saya juga membuat halaman detail yang muncul saat card ditekan, menampilkan seluruh atribut item. Terakhir, saya menambahkan halaman “My Products” yang menampilkan hanya item milik user login dengan cara memanggil endpoint khusus yang memfilter produk berdasarkan user.